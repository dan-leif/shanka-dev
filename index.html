<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<link rel="manifest" href="manifest.webmanifest">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>閃卡</title>
<script>
  function addDevIndicator() {
    if (window.location.pathname.includes('shanka-dev') || window.location.hostname.includes('shanka-dev')) {
      document.title = '閃卡 - DEV';
      
      // Add tiny DEV badge
      const badge = document.createElement('div');
      badge.textContent = 'DEV';
      badge.style.cssText = `
      position: fixed;
      bottom: 18px;
      right: 18px;
      background: #111318;
      color: #303645;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: bold;
      z-index: 9999;
      pointer-events: none;
      font-family: system-ui, sans-serif;
      border: 1px solid #303645;
      `;
      document.body.appendChild(badge);
    }
  }
  
  function addVersionIndicator() {
    // Get version from loading screen or default
    const versionEl = document.getElementById('loadingVersion');
    const version = versionEl ? versionEl.textContent.trim() : 'v3.4';
    
    // Add version badge (always visible)
    const badge = document.createElement('div');
    badge.textContent = version;
    badge.style.cssText = `
      position: fixed;
      bottom: 18px;
      left: 18px;
      background: #111318;
      color: #303645;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: bold;
      z-index: 9999;
      pointer-events: none;
      font-family: system-ui, sans-serif;
      border: 1px solid #303645;
      `;
    document.body.appendChild(badge);
  }
  
  // Run when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      addDevIndicator();
      addVersionIndicator();
    });
  } else {
    addDevIndicator();
    addVersionIndicator();
  }
</script>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --bg:#0b0c10; --panel:#111318; --text:#f5f5f5; --muted:#94a3b8;
    --btn:#1a1f29; --btn-border:#303645; --btn-hover:#232a37; --accent:#44d1bf;
    --divider:#232834; --radius:16px;
    --zh-size:64px; --py-size:24px;
  }

  /* Prefer TW Kai, fall back to WenKai TC Light (local files) */
  @font-face{
    font-family:'TW Kai';
    src:url('./tw-kai.ttf') format('truetype');
    font-weight:400; font-style:normal; font-display:block;
  }
  @font-face{
    font-family:'WenKaiTCLight';
    src:url('./fonts/LXGWWenKaiTC-Light.ttf') format('truetype');
    font-weight:300; font-style:normal; font-display:swap;
  }

  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overflow:hidden;overscroll-behavior:none;}
  .wrap{height:100vh;display:flex;align-items:center;justify-content:center;padding:10px}
  .app{height:calc(100vh - 20px);width:min(780px,96vw);background:var(--panel);border:1px solid #1d2230;border-radius:var(--radius);box-shadow:0 8px 32px rgba(0,0,0,.35);display:flex;flex-direction:column;overflow:hidden}
  
  /* Fullscreen mode styles */
  @media (display-mode: fullscreen) {
    .wrap{padding:0;background:var(--panel)}
    .app{height:100vh;width:100vw;border:none;border-radius:0;box-shadow:none}
  }

  /* Loading screen */
  #loadingScreen{
    position:fixed;top:0;left:0;width:100vw;height:100vh;background:var(--bg);
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    z-index:9999;transition:opacity 0.3s ease-out;
    opacity:0; /* Start hidden */
  }
  #loadingScreen.show{opacity:1}
  #loadingScreen.hidden{opacity:0;pointer-events:none}
  #loadingIcon{width:min(200px,40vw);height:auto;margin-bottom:20px;opacity:0.9}
  #loadingText{color:var(--text);font-size:18px;font-weight:500}
  #loadingVersion{color:var(--muted);font-size:12px;margin-top:8px;opacity:0.7}

  /* Toolbar */
  .bar{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px}
  .left, .right{display:flex;gap:8px;align-items:center}
  .select{background:var(--btn);border:1px solid var(--btn-border);color:var(--text);border-radius:10px;padding:8px 10px;font-size:15px}
  .iconbtn{background:var(--btn);border:1px solid var(--btn-border);color:var(--text);border-radius:12px;padding:10px 14px;font-size:18px;line-height:1;cursor:pointer}
  .iconbtn:hover{background:var(--btn-hover)}
  .iconbtn.active{color:var(--accent);border-color:#2b6b63}

  /* Split area */
  .main{flex:1;display:flex;flex-direction:column;min-height:0}
  .top{flex:4;position:relative;padding:8px 12px 4px;min-height:0;touch-action:pan-y;}
  .divider{height:1px;background:var(--divider)}
  .bottom{flex:6;position:relative;min-height:0}
  #pad{position:absolute;inset:0;touch-action:none}

  /* Two-card stage */
  .stage{position:absolute;inset:0;overflow:hidden}
  .card{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;opacity:1;transform:translate3d(0,0,0);
        transition:transform .22s ease, opacity .22s ease; will-change:transform,opacity;min-height:100%}
  .to-left{transform:translate3d(-40%,0,0);opacity:0}
  .to-right{transform:translate3d(40%,0,0);opacity:0}
  .hidden{display:none}

  /* Card content */
  .panel{max-width:94%;text-align:center;min-height:200px;display:flex;flex-direction:column;justify-content:center;height:200px}
  .en{font-size:clamp(18px,3.8vw,28px);font-weight:800}
  .zh{font-family:'TW Kai','WenKaiTCLight','KaiTi','STKaiti','Kaiti SC','DFKai-SB',serif;
      font-size:var(--zh-size);line-height:1.12;font-weight:400;white-space:pre-line}
  .py{font-size:var(--py-size);color:var(--muted);margin-top:4px}
  .sub{display:block;margin-top:6px}
  /* Hide the prompt when the back is shown to prevent duplication */
  .showBack .frontPrompt{display:none;}

  /* Shadow overlay */
  #shadowWrap{position:absolute;inset:0;display:none;align-items:center;justify-content:center;pointer-events:none}
  #shadowChar{color:#fff;opacity:.14;line-height:1;text-align:center;font-weight:400;
              font-family:'TW Kai','WenKaiTCLight','KaiTi','STKaiti','Kaiti SC','DFKai-SB',serif;}
  .clearBtn{position:absolute;left:8px;top:8px;z-index:3;width:36px;height:36px;border-radius:9px;border:1px solid var(--btn-border);background:var(--btn);color:var(--text);display:grid;place-items:center;font-size:16px}

  /* Progress */
  .progress{display:flex;justify-content:center;padding:10px;height:28px;align-items:center;gap:var(--dot-gap, 6px)}
  .dot{width:var(--dot-width, 8px);height:8px;border-radius:999px;background:#262a36;position:relative;flex-shrink:0}
  .dot.again{background:#ff6b6b}
  .dot.hard{background:#ffa726}
  .dot.good{background:#66bb6a}
  .dot.easy{background:#42a5f5}
  .dot.active{background:#fff}

  /* Rating buttons */
  .rating-btns{display:flex;gap:8px;justify-content:center;padding:10px;border-top:1px solid var(--divider);min-height:60px;align-items:center}
  .rating-btn{background:var(--btn);border:1px solid var(--btn-border);color:var(--text);border-radius:12px;padding:12px 16px;font-size:14px;font-weight:600;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:4px;transition:all 0.2s ease;min-width:70px}
  .rating-btn:hover{background:var(--btn-hover);transform:translateY(-1px)}
  .rating-btn .interval{font-size:11px;opacity:0.7;font-weight:400}
  .rating-btn.again{color:#ff6b6b;border-color:#ff6b6b40}
  .rating-btn.again:hover{background:#ff6b6b20}
  .rating-btn.hard{color:#ffa726;border-color:#ffa72640}
  .rating-btn.hard:hover{background:#ffa72620}
  .rating-btn.good{color:#66bb6a;border-color:#66bb6a40}
  .rating-btn.good:hover{background:#66bb6a20}
  .rating-btn.easy{color:#42a5f5;border-color:#42a5f540}
  .rating-btn.easy:hover{background:#42a5f520}
</style>
</head>
<body>
<div id="loadingScreen">
  <img id="loadingIcon" src="icons/icon-1024-full.png" alt="Loading">
  <div id="loadingText">Loading...</div>
  <div id="loadingVersion">v3.4</div>
</div>
<div class="wrap">
  <div class="app">
    <div class="bar">
      <div class="left">
        <select id="lessonSelect" class="select" title="Lessons"></select>
        <select id="modeSelect" class="select" title="Prompt">
          <option value="EN">英</option>
          <option value="TRAD">正</option>
          <option value="SIMP">简</option>
          <option value="PINYIN">拼</option>
        </select>
      </div>
      <div class="right">
        <button id="starBtn"   class="iconbtn" title="Mark for review">★</button>
        <button id="freezeBtn" class="iconbtn" title="Shadow + Freeze">◐</button>
        <button id="fsBtn"     class="iconbtn" title="Fullscreen">⛶</button>
      </div>
    </div>

    <div class="main">
      <div id="topPane" class="top" aria-label="Flashcard area (tap to flip, swipe to change)">
        <div class="stage" id="stage">
          <!-- Active card -->
          <div class="card" id="cardA">
            <div class="panel">
              <div id="aPrompt" class="frontPrompt en">—</div>
              <div id="aBack">
                <div id="aZh" class="zh hidden">—</div>
                <div id="aPy" class="py hidden">—</div>
                <div id="aEn" class="en hidden" style="font-size:20px;opacity:.9;margin-top:6px">—</div>
              </div>
            </div>
          </div>
          <!-- Incoming/standby card -->
          <div class="card" id="cardB">
            <div class="panel">
              <div id="bPrompt" class="frontPrompt en">—</div>
              <div id="bBack">
                <div id="bZh" class="zh hidden">—</div>
                <div id="bPy" class="py hidden">—</div>
                <div id="bEn" class="en hidden" style="font-size:20px;opacity:.9;margin-top:6px">—</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="divider"></div>
      <div class="bottom" id="drawPane">
        <div id="shadowWrap"><div id="shadowChar"></div></div>
        <button id="clearBtn" class="clearBtn" title="Clear">✕</button>
        <canvas id="pad"></canvas>
      </div>
    </div>

    <div id="progress" class="progress"></div>
    
    <!-- Rating buttons for SRS -->
    <div id="ratingButtons" class="rating-btns hidden">
      <button data-rating="0" class="rating-btn again">Again<span class="interval">10m</span></button>
      <button data-rating="1" class="rating-btn hard">Hard<span class="interval">1d</span></button>
      <button data-rating="2" class="rating-btn good">Good<span class="interval">3d</span></button>
      <button data-rating="3" class="rating-btn easy">Easy<span class="interval">7d</span></button>
    </div>
  </div>
</div>

<script src="./vocab-1.js?v=3.4"></script>
<script>
(function(){
  /* ------------ Font Loading Detection ------------ */
  const loadingScreen = document.getElementById('loadingScreen');
  const loadingIcon = document.getElementById('loadingIcon');
  
  // Function to show loading screen (after image loads)
  function showLoadingScreen() {
    loadingScreen.classList.add('show');
  }
  
  // Function to hide loading screen
  function hideLoadingScreen() {
    loadingScreen.classList.add('hidden');
    setTimeout(() => {
      loadingScreen.style.display = 'none';
    }, 300); // Match CSS transition duration
  }
  
  // Show loading screen only after the icon image loads
  loadingIcon.addEventListener('load', showLoadingScreen);
  // Fallback: show after a short delay if image is already cached
  if (loadingIcon.complete) {
    showLoadingScreen();
  } else {
    setTimeout(showLoadingScreen, 100);
  }
  
  // Check if TW Kai font is actually loaded and rendered
  function checkFontLoaded() {
    if (document.fonts && document.fonts.check) {
      return document.fonts.check('16px "TW Kai"');
    }
    return false;
  }
  
  // Wait for the specific font to load
  function waitForFont() {
    if (checkFontLoaded()) {
      hideLoadingScreen();
      return;
    }
    
    // Use document.fonts.load() to ensure the font is actually loaded
    if (document.fonts && document.fonts.load) {
      document.fonts.load('16px "TW Kai"').then(() => {
        // Add a small delay to ensure the font is fully rendered
        setTimeout(hideLoadingScreen, 100);
      }).catch(() => {
        // Fallback if font loading fails
        setTimeout(hideLoadingScreen, 1000);
      });
    } else {
      // Fallback for older browsers
      setTimeout(hideLoadingScreen, 1500);
    }
  }
  
  // Start checking for font load
  waitForFont();
  
  // Safety timeout to prevent infinite loading
  setTimeout(hideLoadingScreen, 4000);

  /* ------------ IndexedDB Setup ------------ */
  let db = null;
  const DB_NAME = 'shan_srs';
  const DB_VERSION = 1;

  function initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        db = request.result;
        resolve(db);
      };
      
      request.onupgradeneeded = (event) => {
        const database = event.target.result;
        
        // Scheduler store: tracks SRS state per card
        if (!database.objectStoreNames.contains('scheduler')) {
          const schedulerStore = database.createObjectStore('scheduler', { keyPath: 'card_id' });
          schedulerStore.createIndex('next_due', 'next_due', { unique: false });
        }
        
        // Reviews store: logs all review attempts
        if (!database.objectStoreNames.contains('reviews')) {
          const reviewsStore = database.createObjectStore('reviews', { keyPath: 'id', autoIncrement: true });
          reviewsStore.createIndex('card_id', 'card_id', { unique: false });
          reviewsStore.createIndex('ts', 'ts', { unique: false });
        }
      };
    });
  }

  async function getSchedulerState(cardId) {
    if (!db) return null;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['scheduler'], 'readonly');
      const store = transaction.objectStore('scheduler');
      const request = store.get(cardId);
      
      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => reject(request.error);
    });
  }

  async function saveSchedulerState(cardId, state) {
    if (!db) return;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['scheduler'], 'readwrite');
      const store = transaction.objectStore('scheduler');
      const request = store.put({ card_id: cardId, ...state });
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async function logReview(cardId, rating, responseTime = 0) {
    if (!db) return;
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['reviews'], 'readwrite');
      const store = transaction.objectStore('reviews');
      const request = store.add({
        card_id: cardId,
        ts: Date.now(),
        rating: rating,
        response_time_ms: responseTime
      });
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async function getDueCards() {
    if (!db) return [];
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['scheduler'], 'readonly');
      const store = transaction.objectStore('scheduler');
      const index = store.index('next_due');
      const request = index.getAll(IDBKeyRange.upperBound(Date.now()));
      
      request.onsuccess = () => {
        const results = request.result || [];
        // Sort by next_due ascending (most overdue first)
        results.sort((a, b) => a.next_due - b.next_due);
        resolve(results);
      };
      request.onerror = () => reject(request.error);
    });
  }

  /* ------------ SM-2 Algorithm ------------ */
  function calculateNextReview(rating, currentState) {
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000;
    const tenMinutes = 10 * 60 * 1000;
    
    // Initialize if first review
    if (!currentState) {
      currentState = {
        interval: 1,
        ease_factor: 2.5,
        reps: 0,
        lapses: 0,
        last_reviewed: now
      };
    }
    
    let newInterval, newEaseFactor, newReps, newLapses;
    
    if (rating === 0) { // Again
      newInterval = tenMinutes;
      newEaseFactor = Math.max(1.3, currentState.ease_factor - 0.2);
      newReps = 0;
      newLapses = currentState.lapses + 1;
    } else if (rating === 1) { // Hard
      newInterval = oneDay;
      newEaseFactor = Math.max(1.3, currentState.ease_factor - 0.15);
      newReps = currentState.reps + 1;
      newLapses = currentState.lapses;
    } else if (rating === 2) { // Good
      if (currentState.reps === 0) {
        newInterval = oneDay;
      } else if (currentState.reps === 1) {
        newInterval = 3 * oneDay;
      } else {
        newInterval = Math.round(currentState.interval * currentState.ease_factor);
      }
      newEaseFactor = currentState.ease_factor;
      newReps = currentState.reps + 1;
      newLapses = currentState.lapses;
    } else { // Easy (rating === 3)
      if (currentState.reps === 0) {
        newInterval = 4 * oneDay;
      } else {
        newInterval = Math.round(currentState.interval * currentState.ease_factor * 1.3);
      }
      newEaseFactor = currentState.ease_factor + 0.15;
      newReps = currentState.reps + 1;
      newLapses = currentState.lapses;
    }
    
    return {
      interval: newInterval,
      ease_factor: newEaseFactor,
      reps: newReps,
      lapses: newLapses,
      next_due: now + newInterval,
      last_reviewed: now
    };
  }

  function formatInterval(intervalMs) {
    const minutes = Math.floor(intervalMs / (60 * 1000));
    const hours = Math.floor(intervalMs / (60 * 60 * 1000));
    const days = Math.floor(intervalMs / (24 * 60 * 60 * 1000));
    
    if (days > 0) return `${days}d`;
    if (hours > 0) return `${hours}h`;
    if (minutes > 0) return `${minutes}m`;
    return 'now';
  }

  /* ------------ Data ------------ */
  const RAW = (window.VOCAB && window.VOCAB.lessons) || {};
  const LESSONS = {};
  Object.keys(RAW).forEach(k=>{
    const m=k.match(/Lesson\\s+(\\d+-\\d+)/i);
    const key=m?`L${m[1]}`:k;
    const items=(RAW[k]||[]).map((c,i)=>({
      ...c, id:`${key}:${i}:${(c.trad||'')}/${(c.simp||'')}/${(c.en||'')}`
    }));
    LESSONS[key]=items;
  });
  const ORDERED = Object.keys(LESSONS).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}));
  const ALL = ORDERED.flatMap(k=>LESSONS[k]);

  /* ------------ Refs ------------ */
  const $=s=>document.querySelector(s);
  const lessonSelect=$('#lessonSelect'), modeSelect=$('#modeSelect');
  const starBtn=$('#starBtn'), freezeBtn=$('#freezeBtn'), fsBtn=$('#fsBtn');
  const stage=$('#stage'), cardA=$('#cardA'), cardB=$('#cardB');
  const aPrompt=$('#aPrompt'), aZh=$('#aZh'), aPy=$('#aPy'), aEn=$('#aEn');
  const bPrompt=$('#bPrompt'), bZh=$('#bZh'), bPy=$('#bPy'), bEn=$('#bEn');
  const topPane=$('#topPane');
  const progress=$('#progress');
  const drawPane=$('#drawPane'), pad=$('#pad'), clearBtn=$('#clearBtn');
  const shadowWrap=$('#shadowWrap'), shadowChar=$('#shadowChar');
  const ratingButtons=$('#ratingButtons');

  /* ------------ State ------------ */
  const REVIEW_KEY='shan_review_v1';
  let reviewSet=new Set();
  try{const raw=localStorage.getItem(REVIEW_KEY); if(raw) reviewSet=new Set(JSON.parse(raw));}catch(e){}

  let deck=ALL.slice(); let order=deck.map((_,i)=>i);
  const state={ key:'ALL', index:0, revealed:false, freeze:false, shadowGlyph:'', prompt:'EN' };

  function saveReview(){try{localStorage.setItem(REVIEW_KEY,JSON.stringify([...reviewSet]));}catch(e){}}
  function current(){ return deck[order[state.index]] || {en:'—',trad:'—',simp:'—',py:'—',id:'_'}; }
  function fmtZh(trad,simp){ return (trad && simp && trad!==simp) ? (trad + '\\n' + simp).replace(/\\n/g,'<span class="sub"></span>') : (trad || simp || '—'); }

  /* ------------ Deck UI ------------ */
  function updateReviewCountLabel(){
    // Update just the Review option text without rebuilding the entire dropdown
    const options = lessonSelect.options;
    for (let i = 0; i < options.length; i++) {
      if (options[i].value === 'REVIEW') {
        options[i].text = `Review (★) (${reviewSet.size})`;
        return;
      }
    }
  }
  
  async function refreshCountsLabel(){
    const was=lessonSelect.value;
    lessonSelect.innerHTML='';
    lessonSelect.append(new Option(`All lessons (${ALL.length})`,'ALL'));
    ORDERED.forEach(k=>lessonSelect.append(new Option(`${k} (${LESSONS[k].length})`,k)));
    lessonSelect.append(new Option(`Review (★) (${reviewSet.size})`,'REVIEW'));
    
    // Add due cards count
    try {
      const dueCards = await getDueCards();
      lessonSelect.append(new Option(`Due for Review (${dueCards.length})`,'DUE'));
    } catch (error) {
      console.error('Error getting due cards:', error);
      lessonSelect.append(new Option(`Due for Review (0)`,'DUE'));
    }
    
    lessonSelect.value=(was && [...lessonSelect.options].some(o=>o.value===was))?was:'ALL';
  }
  async function setDeckFor(key){
    state.key=key; state.index=0; state.revealed=false;
    
    // Add a brief fade to mask any layout shifts
    const stage = document.getElementById('stage');
    stage.style.transition = 'opacity 0.1s ease';
    stage.style.opacity = '0.7';
    
    // Temporarily disable transitions to prevent visual jumps
    cardA.style.transition = 'none';
    cardB.style.transition = 'none';
    
    if (key === 'ALL') {
      deck = ALL.slice();
    } else if (key === 'REVIEW') {
      deck = ALL.filter(c=>reviewSet.has(c.id));
    } else if (key === 'DUE') {
      try {
        const dueCards = await getDueCards();
        // Create deck from due card IDs, maintaining order
        deck = dueCards.map(dueCard => {
          return ALL.find(card => card.id === dueCard.card_id);
        }).filter(card => card); // Remove any undefined entries
        
        // If no due cards, show a placeholder
        if (deck.length === 0) {
          deck = [{
            id: 'no-due-cards',
            en: 'All caught up!',
            trad: '全部完成！',
            simp: '全部完成！',
            py: 'quánbù wánchéng!'
          }];
        }
      } catch (error) {
        console.error('Error loading due cards:', error);
        deck = [];
      }
    } else {
      deck = LESSONS[key].slice();
    }
    
    order=deck.map((_,i)=>i);
    paintCard(cardA, aPrompt, aZh, aPy, aEn, current(), state.prompt, state.revealed);
    paintCard(cardB, bPrompt, bZh, bPy, bEn, {}, state.prompt, false);
    cardA.classList.remove('hidden'); cardB.classList.add('hidden');
    active='A';
    
    // Update star button state for current card
    updateStarButton();
    
    // Ensure rating buttons are hidden when switching lessons
    ratingButtons.classList.add('hidden');
    
    // Only rebuild dots if the deck size changed, otherwise just update active dot
    const currentDotCount = progress.querySelectorAll('.dot').length;
    if (currentDotCount !== deck.length) {
      drawDots();
    } else {
      updateActiveDot();
    }
    
    // Re-enable transitions and restore opacity after a brief delay
    setTimeout(() => {
      cardA.style.transition = '';
      cardB.style.transition = '';
      stage.style.opacity = '1';
      stage.style.transition = '';
    }, 100);
  }

  /* ------------ Paint helpers ------------ */
  function setPrompt(el, mode, c){
    if(mode==='EN'){ el.className='frontPrompt en'; el.textContent=c.en||'—'; }
    else if(mode==='TRAD'){ el.className='frontPrompt zh'; el.textContent=c.trad||c.simp||'—'; }
    else if(mode==='SIMP'){ el.className='frontPrompt zh'; el.textContent=c.simp||c.trad||'—'; }
    else { el.className='frontPrompt py'; el.textContent=c.py||'—'; }
  }
  function showBackOn(card, show){
    card.classList.toggle('showBack', !!show);
    const zh = (card===cardA)?aZh:bZh;
    const py = (card===cardA)?aPy:bPy;
    const en = (card===cardA)?aEn:bEn;
    if(show){ zh.classList.remove('hidden'); py.classList.remove('hidden'); en.classList.remove('hidden'); }
    else    { zh.classList.add('hidden');    py.classList.add('hidden');    en.classList.add('hidden'); }
  }
  function paintCard(card, pEl, zhEl, pyEl, enEl, c, mode, revealed){
    const empty = !c || !c.en;
    setPrompt(pEl, mode, empty?{en:'—',trad:'—',simp:'—',py:'—'}:c);
    zhEl.innerHTML=fmtZh(c.trad||'—', c.simp||'—');
    pyEl.textContent=c.py||'—';
    enEl.textContent=c.en||'—';
    showBackOn(card, !!revealed);
  }

  /* ------------ Progress dots ------------ */
  function updateActiveDot(){
    const dots = progress.querySelectorAll('.dot');
    dots.forEach((dot, i) => {
      dot.classList.toggle('active', i === state.index);
    });
  }
  
  function updateStarButton(){
    starBtn.classList.toggle('active', reviewSet.has(current().id));
  }
  
  async function updateDotColor(dotIndex, rating) {
    const dots = progress.querySelectorAll('.dot');
    if (dotIndex >= 0 && dotIndex < dots.length) {
      const dot = dots[dotIndex];
      // Remove all rating classes
      dot.classList.remove('again', 'hard', 'good', 'easy');
      // Add the appropriate class based on rating
      if (rating !== undefined && rating !== null) {
        const ratingClass = ['again', 'hard', 'good', 'easy'][rating];
        if (ratingClass) {
          dot.classList.add(ratingClass);
        }
      }
    }
  }
  
  async function drawDots(){
    // Fade out existing dots
    const existingDots = progress.querySelectorAll('.dot');
    if (existingDots.length > 0) {
      progress.style.transition = 'opacity 0.15s ease';
      progress.style.opacity = '0';
      
      // Wait for fade out, then rebuild
      setTimeout(async () => {
        progress.innerHTML='';
        await buildDots();
        // Fade in new dots
        progress.style.opacity = '1';
        setTimeout(() => {
          progress.style.transition = '';
        }, 150);
      }, 150);
    } else {
      // No existing dots, just build directly
      await buildDots();
    }
  }
  
  function calculateDotDimensions(cardCount) {
    if (cardCount === 0) return { width: 8, gap: 6 };
    
    // Get container width, accounting for padding (10px on each side = 20px total)
    const container = progress.getBoundingClientRect();
    const availableWidth = container.width - 20; // Subtract padding
    
    // Fixed height: 8px (won't change)
    const fixedHeight = 8;
    
    // Minimum width: 1px (can become vertical lines)
    const minWidth = 1;
    const minGap = 0; // Gap can disappear completely
    
    // Maximum width: 8px (square dots)
    const maxWidth = 8;
    const maxGap = 6;
    
    // Calculate: availableWidth = (cardCount * dotWidth) + ((cardCount - 1) * gap)
    // Start by trying with no gap
    let optimalWidth = availableWidth / cardCount;
    
    // If we can fit with max width and gap, use defaults
    if ((cardCount * maxWidth) + ((cardCount - 1) * maxGap) <= availableWidth) {
      return { width: maxWidth, gap: maxGap };
    }
    
    // Calculate optimal width and gap to fit all cards
    // availableWidth = (cardCount * width) + ((cardCount - 1) * gap)
    // Try to maximize width while fitting
    
    // If single card, just use available space (capped at maxWidth)
    if (cardCount === 1) {
      return { width: Math.min(maxWidth, availableWidth), gap: 0 };
    }
    
    // Calculate with minimum gap first
    let width = (availableWidth - (cardCount - 1) * minGap) / cardCount;
    
    // If width is too small, reduce gap to zero and recalculate
    if (width < minWidth) {
      width = availableWidth / cardCount;
      return { width: Math.max(minWidth, width), gap: 0 };
    }
    
    // If width is larger than max, use max and calculate gap
    if (width > maxWidth) {
      width = maxWidth;
      const remainingSpace = availableWidth - (cardCount * maxWidth);
      const gap = cardCount > 1 ? Math.max(minGap, Math.min(maxGap, remainingSpace / (cardCount - 1))) : 0;
      return { width: maxWidth, gap: gap };
    }
    
    // Width is between min and max, calculate gap
    const remainingSpace = availableWidth - (cardCount * width);
    const gap = cardCount > 1 ? Math.max(minGap, remainingSpace / (cardCount - 1)) : 0;
    
    return { width: Math.max(minWidth, width), gap: Math.max(minGap, gap) };
  }
  
  async function buildDots() {
    // Calculate dot dimensions to fit all cards
    const dimensions = calculateDotDimensions(order.length);
    progress.style.setProperty('--dot-width', `${dimensions.width}px`);
    progress.style.setProperty('--dot-gap', `${dimensions.gap}px`);
    
    for(let i=0;i<order.length;i++){
      const d=document.createElement('div');
      d.className='dot';
      
      // Add rating-based color indicator
      try {
        const card = deck[order[i]];
        if (card && card.id) {
          const schedulerState = await getSchedulerState(card.id);
          if (schedulerState && schedulerState.last_rating !== undefined) {
            // Map rating to CSS class: 0=again, 1=hard, 2=good, 3=easy
            const ratingClass = ['again', 'hard', 'good', 'easy'][schedulerState.last_rating];
            if (ratingClass) {
              d.classList.add(ratingClass);
            }
          }
        }
      } catch (error) {
        console.error('Error getting rating for dot:', error);
      }
      
      if(i===state.index) d.classList.add('active');
      progress.appendChild(d);
    }
    updateStarButton();
    freezeBtn.classList.toggle('active', state.freeze);
  }

  /* ------------ Card navigation ------------ */
  let active='A';
  function goto(nextIndex, dir){
    if(order.length===0) return;
    const nextCard = (active==='A')?cardB:cardA;
    const nextP = (active==='A')?bPrompt:aPrompt;
    const nextZh = (active==='A')?bZh:aZh;
    const nextPy = (active==='A')?bPy:aPy;
    const nextEn = (active==='A')?bEn:aEn;
    const curCard = (active==='A')?cardA:cardB;

    const idx = (nextIndex+order.length)%order.length;
    state.index = idx;
    state.revealed=false;
    paintCard(nextCard, nextP, nextZh, nextPy, nextEn, current(), state.prompt, false);

    nextCard.classList.remove('hidden','to-left','to-right');
    curCard.classList.remove('to-left','to-right');
    nextCard.style.transition='none'; curCard.style.transition='none';
    if(dir<0){ nextCard.classList.add('to-right'); } else { nextCard.classList.add('to-left'); }
    nextCard.getBoundingClientRect();

    nextCard.style.transition='transform .22s ease, opacity .22s ease';
    curCard.style.transition='transform .22s ease, opacity .22s ease';
    if(dir<0){ curCard.classList.add('to-left'); nextCard.classList.remove('to-right'); }
    else     { curCard.classList.add('to-right'); nextCard.classList.remove('to-left'); }

    const done=()=>{
      curCard.classList.add('hidden');
      curCard.classList.remove('to-left','to-right');
      nextCard.style.transition=''; curCard.style.transition='';
      active = (active==='A')?'B':'A';
      stage.removeEventListener('transitionend', done);
      // Only update the active dot instead of rebuilding all dots
      updateActiveDot();
      updateStarButton();
    };
    stage.addEventListener('transitionend', done, {once:true});
  }

  function flip(){
    const card = (active==='A')?cardA:cardB;
    state.revealed=!state.revealed;
    showBackOn(card, state.revealed);
    
    // Show rating buttons only when card is revealed
    if (state.revealed) {
      ratingButtons.classList.remove('hidden');
      updateRatingButtonLabels();
    } else {
      ratingButtons.classList.add('hidden');
    }
  }

  async function updateRatingButtonLabels() {
    const currentCard = current();
    if (!currentCard || !currentCard.id) return;
    
    try {
      const schedulerState = await getSchedulerState(currentCard.id);
      
      // Update button labels with calculated intervals
      const buttons = ratingButtons.querySelectorAll('.rating-btn');
      buttons.forEach(btn => {
        const rating = parseInt(btn.dataset.rating);
        const newState = calculateNextReview(rating, schedulerState);
        const intervalSpan = btn.querySelector('.interval');
        if (intervalSpan) {
          intervalSpan.textContent = formatInterval(newState.interval);
        }
      });
    } catch (error) {
      console.error('Error updating rating button labels:', error);
    }
  }

  async function handleRating(rating) {
    const currentCard = current();
    if (!currentCard || !currentCard.id || currentCard.id === 'no-due-cards') return;
    
    try {
      // Get current scheduler state
      const schedulerState = await getSchedulerState(currentCard.id);
      
      // Calculate new state
      const newState = calculateNextReview(rating, schedulerState);
      // Store the last rating for dot color coding
      newState.last_rating = rating;
      
      // Save new state
      await saveSchedulerState(currentCard.id, newState);
      
      // Log the review
      await logReview(currentCard.id, rating);
      
      // Update the dot color for the card we just rated
      const currentIndex = state.index;
      await updateDotColor(currentIndex, rating);
      
      // Hide rating buttons
      ratingButtons.classList.add('hidden');
      
      // Advance to next card (direction -1 for right-to-left animation)
      goto(state.index + 1, -1);
      
      // Refresh counts
      refreshCountsLabel();
      
    } catch (error) {
      console.error('Error handling rating:', error);
    }
  }

  /* ------------ Initialize deck ------------ */
  async function initializeApp() {
    try {
      await initDB();
      await refreshCountsLabel();
      await setDeckFor('ALL');
      modeSelect.value=state.prompt;
      lessonSelect.addEventListener('change',()=>setDeckFor(lessonSelect.value));
    } catch (error) {
      console.error('Error initializing app:', error);
    }
  }
  modeSelect.addEventListener('change',()=>{
    state.prompt=modeSelect.value;
    const c=current();
    if(active==='A') paintCard(cardA,aPrompt,aZh,aPy,aEn,c,state.prompt,state.revealed);
    else paintCard(cardB,bPrompt,bZh,bPy,bEn,c,state.prompt,state.revealed);
    updateStarButton();
  });

  /* ------------ Review / Freeze / Fullscreen ------------ */
  starBtn.addEventListener('click',()=>{
    const id=current().id;
    if(reviewSet.has(id)) reviewSet.delete(id); else reviewSet.add(id);
    saveReview();
    updateReviewCountLabel(); // Update just the review count, not the entire dropdown
    updateStarButton(); // Update star button state (dots don't need to change)
  });

  freezeBtn.addEventListener('click',()=>{
    state.freeze=!state.freeze;
    if(!state.freeze){ state.shadowGlyph=''; shadowWrap.style.display='none'; }
    drawDots();
  });

  async function toggleFS(){
    try{
      if(!document.fullscreenElement){ await document.documentElement.requestFullscreen({navigationUI:'hide'}); }
      else { await document.exitFullscreen(); }
    }catch(e){}
  }
  fsBtn.addEventListener('click', toggleFS);
  document.addEventListener('fullscreenchange', ()=>{
    fsBtn.classList.toggle('active', !!document.fullscreenElement);
  });

  /* ------------ Rating Button Handlers ------------ */
  ratingButtons.addEventListener('click', (e) => {
    const button = e.target.closest('.rating-btn');
    if (button) {
      const rating = parseInt(button.dataset.rating);
      handleRating(rating);
    }
  });

  /* ------------ Hanzi picker for Shadow Mode ------------ */
  const hanRegex=/[\u3400-\u9FFF]/;
  function firstHanChar(str){
    if(!str) return '';
    for(const ch of str){ if(hanRegex.test(ch)) return ch; }
    return '';
  }
  function caretRangeAtPoint(x,y){
    if(document.caretRangeFromPoint){
      return document.caretRangeFromPoint(x,y);
    }
    if(document.caretPositionFromPoint){
      const pos=document.caretPositionFromPoint(x,y);
      if(!pos) return null;
      const r=document.createRange();
      r.setStart(pos.offsetNode,pos.offset);
      return r;
    }
    return null;
    }
  function hanziFromPoint(e){
    const r=caretRangeAtPoint(e.clientX,e.clientY);
    if(r && r.startContainer){
      let node=r.startContainer, offset=r.startOffset;

      // If we landed on an element, try to get a nearby text node
      if(node.nodeType!==Node.TEXT_NODE){
        // Try child text
        const walker=document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
        let t=walker.nextNode();
        if(!t && node.parentNode){
          // Try sibling text
          const w2=document.createTreeWalker(node.parentNode, NodeFilter.SHOW_TEXT, null);
          while((t=w2.nextNode())){ if(t.textContent && t.textContent.trim()) break; }
        }
        node=t||node;
        offset=0;
      }

      if(node.nodeType===Node.TEXT_NODE){
        const s=node.textContent||'';
        let i=Math.max(0, Math.min(offset, s.length-1));
        // Prefer exact offset, but scan to nearest Hanzi (left then right)
        if(!hanRegex.test(s[i])){
          let found=-1;
          for(let d=1; d<4 && found<0; d++){
            if(i-d>=0 && hanRegex.test(s[i-d])) found=i-d;
            else if(i+d<s.length && hanRegex.test(s[i+d])) found=i+d;
          }
          if(found>=0) i=found;
        }
        const ch=s[i]||'';
        if(hanRegex.test(ch)) return ch;
      }
    }
    // Fallback: first Hanzi inside tapped element
    const el=e.target.closest('.zh, .frontPrompt');
    return firstHanChar(el?el.textContent:'');
  }

  /* ------------ Gestures (top) ------------ */
  let startX=0,startY=0,dragging=false;
  const SWIPE_X=48, SWIPE_MAX_Y=40;

  topPane.addEventListener('pointerdown',e=>{
    if(state.freeze) return; dragging=true; startX=e.clientX; startY=e.clientY; topPane.setPointerCapture(e.pointerId);
  });
  topPane.addEventListener('pointerup',e=>{
    if(state.freeze || !dragging) return; dragging=false;
    const dx=e.clientX-startX, dy=e.clientY-startY;
    if(Math.abs(dx)>SWIPE_X && Math.abs(dy)<SWIPE_MAX_Y){
      if(dx<0) goto(state.index+1, -1); else goto(state.index-1, +1);
    }else{
      flip();
    }
  });
  topPane.addEventListener('pointercancel',()=>{ dragging=false; });

  // In freeze mode: tap or select a Han character to shadow it
  topPane.addEventListener('click',e=>{
    if(!state.freeze) return;

    // 1) Explicit user selection (long-press)
    let txt = (window.getSelection ? (window.getSelection().toString()||'') : '').trim();
    let ch = firstHanChar(txt);

    // 2) If no selection, pick char exactly under the finger
    if(!ch){ ch = hanziFromPoint(e); }

    if(!ch) return;
    state.shadowGlyph = ch;
    fitShadow(); shadowChar.textContent = state.shadowGlyph;
    shadowWrap.style.display='flex';
  });

  /* ------------ Drawing pad ------------ */
  const ctx=pad.getContext('2d'); let drawing=false,lastX=0,lastY=0;
  function resizePad(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const r=drawPane.getBoundingClientRect();
    pad.width=Math.round(r.width*dpr); pad.height=Math.round(r.height*dpr);
    pad.style.width=r.width+'px'; pad.style.height=r.height+'px';
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr);
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=6; ctx.strokeStyle='rgba(255,255,255,.95)';
    fitShadow();
  }
  function fitShadow(){
    const r=drawPane.getBoundingClientRect();
    shadowChar.style.fontSize = Math.floor(Math.min(r.width,r.height)*0.86)+'px';
  }
  function clearPad(){ ctx.clearRect(0,0,pad.width,pad.height); }
  pad.addEventListener('pointerdown',e=>{
    const r=pad.getBoundingClientRect();
    drawing=true; lastX=e.clientX-r.left; lastY=e.clientY-r.top; pad.setPointerCapture(e.pointerId);
  });
  pad.addEventListener('pointermove',e=>{
    if(!drawing) return;
    const r=pad.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
    ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y;
  });
  pad.addEventListener('pointerup',()=>{ drawing=false; });
  pad.addEventListener('pointercancel',()=>{ drawing=false; });
  clearBtn.addEventListener('click', clearPad);

  window.addEventListener('resize', resizePad, {passive:true});
  window.addEventListener('resize', () => {
    // Recalculate dot dimensions when window resizes
    const currentDotCount = progress.querySelectorAll('.dot').length;
    if (currentDotCount > 0 && currentDotCount === order.length) {
      // Only recalculate if dots are already rendered
      const dimensions = calculateDotDimensions(order.length);
      progress.style.setProperty('--dot-width', `${dimensions.width}px`);
      progress.style.setProperty('--dot-gap', `${dimensions.gap}px`);
    }
  }, {passive:true});
  resizePad();
  drawDots();

  /* ------------ Initial paint ------------ */
  paintCard(cardA,aPrompt,aZh,aPy,aEn,current(),state.prompt,state.revealed);

  /* ------------ Initialize App ------------ */
  initializeApp();

  /* ------------ Service Worker Registration ------------ */
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then(registration => {
          console.log('SW registered: ', registration);
        })
        .catch(registrationError => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }
})();
</script>
</body>
</html>
